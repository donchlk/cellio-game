<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cell.io - Technical Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #f2fbff; font-family: 'Ubuntu', sans-serif; cursor: default; }
        canvas { display: block; }
        #hud { position: absolute; top: 20px; left: 20px; color: #555; pointer-events: none; z-index: 10; }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 5px; min-width: 150px; color: #444; font-size: 14px; backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.1); z-index: 10; }
        .score-val { font-weight: bold; font-size: 20px; }
        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #999; font-size: 12px; z-index: 10; }
        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 100; }
        .login-box { background: white; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .login-box h1 { margin-top: 0; color: #333; }
        .login-box input { width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #ddd; border-radius: 5px; font-size: 16px; box-sizing: border-box; }
        .login-box button { background: #ff3f3f; color: white; border: none; padding: 12px 30px; border-radius: 5px; font-size: 18px; cursor: pointer; transition: 0.2s; }
        .login-box button:hover { background: #e63535; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="login-box">
            <h1>Cell.io</h1>
            <input type="text" id="nickname" placeholder="Nickname" maxlength="15">
            <br>
            <button onclick="startGame()">Play</button>
        </div>
    </div>
    <div id="hud" style="display:none">
        <div class="score-val">Score: <span id="score">0</span></div>
    </div>
    <div id="leaderboard" style="display:none">
        <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; padding-bottom:2px;">Leaderboard</div>
        <div id="lb-content"></div>
    </div>
    <div id="instructions" style="display:none">[Space] Split | [W] Eject Mass | Move Mouse to steer</div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const WORLD_SIZE = 5000, INITIAL_MASS = 250, MIN_SPLIT_MASS = 450, MAX_PIECES = 16, FOOD_COUNT = 1000, VIRUS_COUNT = 35, VIRUS_MASS = 1200;
const BASE_SPEED = 2300, DECAY_RATE = 0.0022, MERGE_BASE = 8, MERGE_FACTOR = 1.3, SPLIT_FORCE = 850, ACCELERATION = 16, EJECT_MASS = 35, EJECT_LOSS = 42;
const COLORS = ['#33ff33', '#3333ff', '#ff3333', '#ffff33', '#ff33ff', '#33ffff', '#ff9900', '#7d5fff'];
const BOT_NAMES = ["Sir Eats-a-lot", "Cell-fie", "Wojak", "Dogecoin", "Sanic", "MemeLord", "Doge", "Spooderman", "Blobby", "AgarioMaster", "ProCell", "Noob", "Ghost", "Predator", "Survivor"];

let lastTime = Date.now(), mouseX = 0, mouseY = 0, playerCells = [], bots = [], foods = [], viruses = [], ejectedMasses = [], camera = { x: WORLD_SIZE/2, y: WORLD_SIZE/2, zoom: 1 };
let gameStarted = false, localPlayerId = null;

const getRadius = (mass) => Math.sqrt(mass);
const getBaseSpeed = (m) => BASE_SPEED / (Math.pow(m, 0.5) + 0.002 * m);

class Cell {
    constructor(id, x, y, mass, color, name, isPlayer = false) {
        this.playerId = id; this.x = x; this.y = y; this.mass = mass; this.color = color; this.name = name; this.isPlayer = isPlayer;
        this.vx = 0; this.vy = 0; this.boostX = 0; this.boostY = 0; this.mergeTimer = 0;
        this.growthBoost = 0; // 0 to 1
        this.speedBoost = 0;  // 0 to 1
    }
    update(dt, targetX, targetY) {
        const r = getRadius(this.mass);
        const s = getBaseSpeed(this.mass) * (1 + 0.05 * Math.exp(-5 * (1 - this.speedBoost)));
        
        if (targetX !== undefined) {
            const dx = targetX - this.x, dy = targetY - this.y, dist = Math.hypot(dx, dy);
            const targetVx = dist > 1 ? (dx / dist) * s : 0;
            const targetVy = dist > 1 ? (dy / dist) * s : 0;
            const acc = (ACCELERATION / Math.sqrt(this.mass));
            this.vx += (targetVx - this.vx) * acc * dt;
            this.vy += (targetVy - this.vy) * acc * dt;
        }

        this.x += (this.vx + this.boostX) * dt;
        this.y += (this.vy + this.boostY) * dt;

        const boostDecay = Math.pow(0.05, dt);
        this.boostX *= boostDecay; this.boostY *= boostDecay;
        
        this.x = Math.max(r, Math.min(WORLD_SIZE - r, this.x));
        this.y = Math.max(r, Math.min(WORLD_SIZE - r, this.y));

        let k = DECAY_RATE;
        if (this.mass > 8000) k *= (1 + (this.mass / 8000));
        if (this.mass > INITIAL_MASS) this.mass -= this.mass * k * dt;
        
        if (this.mergeTimer > 0) this.mergeTimer -= dt;
        if (this.growthBoost > 0) this.growthBoost = Math.max(0, this.growthBoost - 4 * dt);
        if (this.speedBoost > 0) this.speedBoost = Math.max(0, this.speedBoost - 5 * dt);
    }
    draw() {
        const boost = 1 + 0.08 * Math.exp(-4 * (1 - this.growthBoost));
        const r = getRadius(this.mass) * (this.isPlayer || bots.some(b => b.playerId === this.playerId) ? boost : 1);
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
        ctx.lineWidth = Math.max(2, r * 0.04); ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.stroke();
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
        grad.addColorStop(0.8, 'rgba(255,255,255,0)'); grad.addColorStop(1, 'rgba(255,255,255,0.15)');
        ctx.fillStyle = grad; ctx.fill();
        if (r > 12) {
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = `bold ${r * 0.38}px Ubuntu, sans-serif`;
            ctx.fillText(this.name, 0, r * 0.1);
            if (r > 25) {
                ctx.font = `${r * 0.22}px Ubuntu, sans-serif`;
                ctx.fillText(Math.floor(this.mass), 0, r * 0.45);
            }
        }
        ctx.restore();
    }
}

function generateId() { return Math.random().toString(36).substr(2, 9); }

function startGame() {
    const nick = document.getElementById('nickname').value || 'Unnamed Cell';
    localPlayerId = generateId();
    playerCells = [new Cell(localPlayerId, WORLD_SIZE/2, WORLD_SIZE/2, INITIAL_MASS, '#ff3f3f', nick, true)];
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('leaderboard').style.display = 'block';
    document.getElementById('instructions').style.display = 'block';
    gameStarted = true;
}

function spawnFood() {
    foods.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, c: COLORS[Math.floor(Math.random()*COLORS.length)], m: 12 });
}

function update() {
    const now = Date.now(), dt = (now - lastTime) / 1000;
    lastTime = now;
    if (!gameStarted) return;

    if (playerCells.length > 0) {
        let avgX = 0, avgY = 0, totalM = 0;
        playerCells.forEach(c => { avgX += c.x; avgY += c.y; totalM += c.mass; });
        camera.x += (avgX / playerCells.length - camera.x) * 0.1;
        camera.y += (avgY / playerCells.length - camera.y) * 0.1;
        const targetZoom = 2.1 / Math.sqrt(totalM);
        camera.zoom += (targetZoom - camera.zoom) * 0.08;
    } else {
        gameStarted = false;
        document.getElementById('start-screen').style.display = 'flex';
    }

    const worldMouseX = (mouseX - canvas.width/2) / camera.zoom + camera.x;
    const worldMouseY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
    playerCells.forEach(c => c.update(dt, worldMouseX, worldMouseY));
    bots.forEach(b => {
        if (!b.targetFood || Math.random() < 0.01) b.targetFood = foods[Math.floor(Math.random()*foods.length)];
        b.update(dt, b.targetFood.x, b.targetFood.y);
    });
    ejectedMasses.forEach((m, i) => {
        m.x += m.vx * dt; m.y += m.vy * dt;
        const decay = Math.pow(0.05, dt); m.vx *= decay; m.vy *= decay;
    });
    handleCollisions();
    document.getElementById('score').innerText = Math.floor(playerCells.reduce((a,b) => a + b.mass, 0));
}

function handleCollisions() {
    const allLivingCells = [...playerCells, ...bots];
    allLivingCells.forEach(c => {
        const r = getRadius(c.mass);
        for(let i=foods.length-1; i>=0; i--) {
            if (Math.hypot(c.x - foods[i].x, c.y - foods[i].y) < r) {
                c.mass += foods[i].m; foods.splice(i, 1); spawnFood();
                c.growthBoost = 1; c.speedBoost = 1;
            }
        }
    });

    allLivingCells.forEach(c => {
        const r = getRadius(c.mass);
        viruses.forEach(v => {
            const dist = Math.hypot(c.x - v.x, c.y - v.y);
            if (c.mass > v.mass * 1.15 && dist < r) explodeCell(c);
        });
    });

    for(let i=allLivingCells.length-1; i>=0; i--) {
        for(let j=allLivingCells.length-1; j>=0; j--) {
            if (i === j) continue;
            let a = allLivingCells[i], b = allLivingCells[j];
            if (!a || !b) continue;
            const dist = Math.hypot(a.x - b.x, a.y - b.y), ra = getRadius(a.mass), rb = getRadius(b.mass);
            
            if (a.playerId === b.playerId) {
                const mergeTimeA = MERGE_BASE + Math.pow(a.mass, 0.35) * MERGE_FACTOR;
                const mergeTimeB = MERGE_BASE + Math.pow(b.mass, 0.35) * MERGE_FACTOR;
                if (a.mergeTimer <= 0 && b.mergeTimer <= 0 && dist < Math.min(ra, rb)) {
                    a.mass += b.mass;
                    if (a.isPlayer) playerCells.splice(playerCells.indexOf(b), 1);
                    else bots.splice(bots.indexOf(b), 1);
                    return;
                }
                if (dist < ra + rb) {
                    const angle = Math.atan2(b.y - a.y, b.x - a.x);
                    let push = (ra + rb - dist) * 0.1;
                    if (a.mergeTimer < 2 && b.mergeTimer < 2) push *= -0.5; // attraction
                    b.x += Math.cos(angle) * push; b.y += Math.sin(angle) * push;
                }
            } else {
                if (a.mass > b.mass * 1.25 && dist < ra - rb * 0.5) {
                    a.mass += b.mass; a.growthBoost = 1; a.speedBoost = 1;
                    if (b.isPlayer) playerCells.splice(playerCells.indexOf(b), 1);
                    else bots.splice(bots.indexOf(b), 1);
                    if (!b.isPlayer && !bots.some(bot => bot.playerId === b.playerId)) {
                        setTimeout(() => {
                            const newBotId = generateId();
                            bots.push(new Cell(newBotId, Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[Math.floor(Math.random()*COLORS.length)], b.name));
                        }, 5000);
                    }
                }
            }
        }
    }
}

function explodeCell(cell) {
    const pieces = Math.min(MAX_PIECES - playerCells.filter(c => c.playerId === cell.playerId).length, Math.floor(cell.mass / 450));
    if (pieces <= 0) return;
    const actualPieces = Math.min(pieces, 16);
    const fragmentMass = cell.mass / (actualPieces + 1);
    cell.mass = fragmentMass;
    for(let i=0; i<actualPieces; i++) {
        const angle = Math.random() * Math.PI * 2, piece = new Cell(cell.playerId, cell.x, cell.y, fragmentMass, cell.color, cell.name, cell.isPlayer);
        piece.boostX = Math.cos(angle) * 700; piece.boostY = Math.sin(angle) * 700;
        piece.mergeTimer = MERGE_BASE + Math.pow(fragmentMass, 0.35) * MERGE_FACTOR;
        if (cell.isPlayer) playerCells.push(piece); else bots.push(piece);
    }
}

function render() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);
    ctx.strokeStyle = '#e1eff6'; ctx.lineWidth = 1;
    for(let x=0; x<=WORLD_SIZE; x+=50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_SIZE); ctx.stroke(); }
    for(let y=0; y<=WORLD_SIZE; y+=50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_SIZE, y); ctx.stroke(); }
    ctx.strokeStyle = 'rgba(255, 63, 63, 0.4)'; ctx.lineWidth = 15; ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
    foods.forEach(f => { ctx.fillStyle = f.c; ctx.beginPath(); ctx.arc(f.x, f.y, 11, 0, Math.PI*2); ctx.fill(); });
    ejectedMasses.forEach(m => { ctx.fillStyle = m.c; ctx.beginPath(); ctx.arc(m.x, m.y, getRadius(m.mass), 0, Math.PI*2); ctx.fill(); });
    viruses.forEach(v => {
        const r = getRadius(v.mass); ctx.fillStyle = '#33ff33'; ctx.strokeStyle = '#2ac82a'; ctx.lineWidth = 6; ctx.beginPath();
        for(let i=0; i<20; i++) { let angle = (i / 20) * Math.PI * 2, d = i % 2 === 0 ? r : r * 1.15; ctx.lineTo(v.x + Math.cos(angle) * d, v.y + Math.sin(angle) * d); }
        ctx.closePath(); ctx.fill(); ctx.stroke();
    });
    bots.forEach(b => b.draw()); playerCells.forEach(c => c.draw());
    ctx.restore(); updateLeaderboard();
}

function updateLeaderboard() {
    const players = {};
    [...playerCells, ...bots].forEach(c => {
        if (!players[c.playerId]) players[c.playerId] = { name: c.name, mass: 0, isPlayer: c.isPlayer };
        players[c.playerId].mass += c.mass;
    });
    const sorted = Object.values(players).sort((a,b) =&gt; b.mass - a.mass).slice(0, 8);
    document.getElementById('lb-content').innerHTML = sorted.map((p, i) => `<div style="color:${p.isPlayer?'#000':'#666'}">${i+1}. ${p.name} (${Math.floor(p.mass)})</div>`).join("");
}

window.onmousemove = (e) => { mouseX = e.clientX; mouseY = e.clientY; };
window.onkeydown = (e) => {
    if (!gameStarted) return;
    if (e.code === 'Space') {
        const count = playerCells.length;
        if (count >= MAX_PIECES) return;
        const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
        for (let i = 0; i < count; i++) {
            let c = playerCells[i];
            if (c.mass >= MIN_SPLIT_MASS && playerCells.length < MAX_PIECES) {
                const angle = Math.atan2(worldMY - c.y, worldMX - c.x); c.mass /= 2;
                const piece = new Cell(c.playerId, c.x, c.y, c.mass, c.color, c.name, true);
                piece.boostX = Math.cos(angle) * SPLIT_FORCE; piece.boostY = Math.sin(angle) * SPLIT_FORCE;
                const mTime = MERGE_BASE + Math.pow(c.mass, 0.35) * MERGE_FACTOR;
                c.mergeTimer = mTime; piece.mergeTimer = mTime;
                playerCells.push(piece);
            }
        }
    }
    if (e.code === 'KeyW') {
        playerCells.forEach(c => {
            if (c.mass > 120) {
                const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
                const angle = Math.atan2(worldMY - c.y, worldMX - c.x);
                c.mass -= EJECT_LOSS;
                ejectedMasses.push({ x: c.x + Math.cos(angle) * getRadius(c.mass) * 1.1, y: c.y + Math.sin(angle) * getRadius(c.mass) * 1.1, vx: Math.cos(angle) * 600, vy: Math.sin(angle) * 600, mass: EJECT_MASS, c: c.color });
            }
        });
    }
};

function init() {
    for(let i=0; i<FOOD_COUNT; i++) spawnFood();
    for(let i=0; i<VIRUS_COUNT; i++) viruses.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, mass: VIRUS_MASS });
    for(let i=0; i<12; i++) {
        const id = generateId();
        bots.push(new Cell(id, Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[i%COLORS.length], BOT_NAMES[i % BOT_NAMES.length]));
    }
}
function run() { update(); render(); requestAnimationFrame(run); }
init(); run();
</script>
</body>
</html>

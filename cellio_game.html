<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cell.io - Professional Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #f2fbff; font-family: 'Ubuntu', sans-serif; cursor: default; }
        canvas { display: block; }
        #hud { position: absolute; top: 20px; left: 20px; color: #555; pointer-events: none; z-index: 10; font-size: 18px; font-weight: bold; }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.8); padding: 15px; border-radius: 8px; min-width: 180px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); z-index: 10; }
        .lb-title { font-weight: bold; border-bottom: 2px solid #eee; margin-bottom: 8px; padding-bottom: 5px; text-align: center; color: #333; }
        #lb-content { font-size: 14px; line-height: 1.6; }
        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #999; font-size: 13px; z-index: 10; background: rgba(255,255,255,0.5); padding: 5px 15px; border-radius: 20px; }
        #start-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 100; backdrop-filter: blur(5px); }
        .login-box { background: white; padding: 40px; border-radius: 15px; text-align: center; box-shadow: 0 15px 35px rgba(0,0,0,0.3); width: 320px; }
        .login-box h1 { margin-top: 0; color: #333; font-size: 32px; }
        .login-box input { width: 100%; padding: 12px; margin: 20px 0; border: 2px solid #ddd; border-radius: 6px; font-size: 16px; box-sizing: border-box; outline: none; }
        .login-box input:focus { border-color: #ff3f3f; }
        .login-box button { background: #ff3f3f; color: white; border: none; padding: 12px 0; width: 100%; border-radius: 6px; font-size: 18px; font-weight: bold; cursor: pointer; transition: background 0.2s; }
        .login-box button:hover { background: #e63535; }
    </style>
</head>
<body>
    <div id="hud"><div id="score">Score: 0</div></div>
    <div id="leaderboard" style="display:none">
        <div class="lb-title">Leaderboard</div>
        <div id="lb-content"></div>
    </div>
    <div id="instructions" style="display:none">[Space] Split | [W] Eject Mass | Move Mouse to steer</div>
    <div id="start-screen">
        <div class="login-box">
            <h1>Cell.io</h1>
            <input type="text" id="nickname" placeholder="Nickname" maxlength="15">
            <button onclick="startGame()">Play</button>
        </div>
    </div>
    <canvas id="game"></canvas>
    <script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
    const WORLD_SIZE = 5000, INITIAL_MASS = 250, MIN_SPLIT_MASS = 450, MAX_PIECES = 16;
    const FOOD_COUNT = 1000, VIRUS_COUNT = 35, VIRUS_MASS = 1200;
    const BASE_SPEED = 2300, DECAY_RATE = 0.0022, MERGE_BASE = 8, MERGE_FACTOR = 1.3;
    const SPLIT_FORCE = 850, ACCELERATION = 16, EJECT_MASS = 35, EJECT_LOSS = 38;
    const COLORS = ['#33ff33', '#3333ff', '#ff3333', '#ffff33', '#ff33ff', '#33ffff', '#ff9900', '#7d5fff'];
    const BOT_NAMES = ["Sir Eats-a-lot", "Cell-fie", "Wojak", "Dogecoin", "Sanic", "MemeLord", "Doge", "Spooderman", "Blobby", "AgarioMaster", "ProPlayer", "Massive"];

    let lastTime = Date.now(), mouseX = 0, mouseY = 0, playerCells = [], bots = [], foods = [], viruses = [], ejectedMasses = [];
    let gameStarted = false, localPlayerId = null, camera = { x: WORLD_SIZE/2, y: WORLD_SIZE/2, zoom: 1 };

    const getRadius = (mass) => Math.sqrt(mass);
    const getBaseSpeed = (m) => BASE_SPEED / (Math.pow(m, 0.5) + 0.002 * m);

    class Cell {
        constructor(id, x, y, mass, color, name, isPlayer = false) {
            this.playerId = id; this.x = x; this.y = y; this.mass = mass; this.color = color; this.name = name; this.isPlayer = isPlayer;
            this.vx = 0; this.vy = 0; this.boostX = 0; this.boostY = 0; this.mergeTimer = 0;
            this.growthBoost = 0; this.speedBoost = 0;
        }
        update(dt, targetX, targetY) {
            const s = getBaseSpeed(this.mass);
            if (targetX !== undefined) {
                const dx = targetX - this.x, dy = targetY - this.y, dist = Math.hypot(dx, dy);
                const targetVx = dist > 1 ? (dx / dist) * s : 0;
                const targetVy = dist > 1 ? (dy / dist) * s : 0;
                const acc = (ACCELERATION / Math.sqrt(this.mass));
                this.vx += (targetVx - this.vx) * acc * dt;
                this.vy += (targetVy - this.vy) * acc * dt;
            }
            this.x += (this.vx + this.boostX) * dt;
            this.y += (this.vy + this.boostY) * dt;
            const boostDecay = Math.pow(0.05, dt);
            this.boostX *= boostDecay; this.boostY *= boostDecay;
            const r = getRadius(this.mass);
            this.x = Math.max(r, Math.min(WORLD_SIZE - r, this.x));
            this.y = Math.max(r, Math.min(WORLD_SIZE - r, this.y));
            let k = DECAY_RATE;
            if (this.mass > 8000) k *= (1 + (this.mass / 8000));
            if (this.mass > INITIAL_MASS) this.mass -= this.mass * k * dt;
            if (this.mergeTimer > 0) this.mergeTimer -= dt;
            if (this.growthBoost > 0) this.growthBoost = Math.max(0, this.growthBoost - 4 * dt);
            if (this.speedBoost > 0) this.speedBoost = Math.max(0, this.speedBoost - 5 * dt);
        }
        draw() {
            const boost = 1 + 0.08 * Math.exp(-4 * (1 - this.growthBoost));
            const r = getRadius(this.mass) * (this.isPlayer || bots.some(b => b.playerId === this.playerId) ? boost : 1);
            ctx.save(); ctx.translate(this.x, this.y);
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
            ctx.lineWidth = Math.max(2, r * 0.04); ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.stroke();
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = `bold ${r * 0.38}px Ubuntu, sans-serif`;
            ctx.fillText(this.name, 0, r * 0.1);
            if (r > 25) {
                ctx.font = `${r * 0.22}px Ubuntu, sans-serif`;
                ctx.fillText(Math.floor(this.mass), 0, r * 0.45);
            }
            ctx.restore();
        }
    }

    function generateId() { return Math.random().toString(36).substr(2, 9); }

    function startGame() {
        const nickInput = document.getElementById('nickname');
        const nick = nickInput.value || 'Unnamed Cell';
        localPlayerId = generateId();
        playerCells = [new Cell(localPlayerId, WORLD_SIZE/2, WORLD_SIZE/2, INITIAL_MASS, '#ff3f3f', nick, true)];
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('leaderboard').style.display = 'block';
        document.getElementById('instructions').style.display = 'block';
        gameStarted = true;
    }

    function spawnFood() {
        foods.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, c: COLORS[Math.floor(Math.random()*COLORS.length)], m: 12 });
    }

    function handleCollisions() {
        const allLivingCells = [...playerCells, ...bots];
        allLivingCells.forEach(c => {
            const r = getRadius(c.mass);
            for(let i=foods.length-1; i>=0; i--) {
                if (Math.hypot(c.x - foods[i].x, c.y - foods[i].y) < r) {
                    c.mass += foods[i].m; foods.splice(i, 1); spawnFood();
                    c.growthBoost = 1; c.speedBoost = 1;
                }
            }
        });

        allLivingCells.forEach(c => {
            const r = getRadius(c.mass);
            viruses.forEach(v => {
                const dist = Math.hypot(c.x - v.x, c.y - v.y);
                if (c.mass > v.mass * 1.15 && dist < r) explodeCell(c);
            });
        });

        for(let i=allLivingCells.length-1; i>=0; i--) {
            for(let j=allLivingCells.length-1; j>=0; j--) {
                if (i === j) continue;
                let a = allLivingCells[i], b = allLivingCells[j];
                if (!a || !b) continue;
                const dist = Math.hypot(a.x - b.x, a.y - b.y), ra = getRadius(a.mass), rb = getRadius(b.mass);
                if (a.playerId === b.playerId) {
                    if (a.mergeTimer <= 0 && b.mergeTimer <= 0 && dist < Math.min(ra, rb)) {
                        a.mass += b.mass;
                        if (b.isPlayer) playerCells.splice(playerCells.indexOf(b), 1); else bots.splice(bots.indexOf(b), 1);
                        return;
                    }
                    const overlap = ra + rb - dist;
                    if (overlap > 0) {
                        const angle = Math.atan2(b.y - a.y, b.x - a.x), push = overlap * 0.5;
                        if (a.mergeTimer < 2 && b.mergeTimer < 2) push *= -0.5;
                        b.x += Math.cos(angle) * push; b.y += Math.sin(angle) * push;
                    }
                } else {
                    if (a.mass > b.mass * 1.25 && dist < ra - rb * 0.5) {
                        a.mass += b.mass; a.growthBoost = 1; a.speedBoost = 1;
                        if (b.isPlayer) playerCells.splice(playerCells.indexOf(b), 1); else bots.splice(bots.indexOf(b), 1);
                        if (!b.isPlayer && !bots.some(bot => bot.playerId === b.playerId)) {
                            setTimeout(() => {
                                const newBotId = generateId();
                                bots.push(new Cell(newBotId, Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[Math.floor(Math.random()*COLORS.length)], BOT_NAMES[Math.floor(Math.random()*BOT_NAMES.length)]));
                            }, 5000);
                        }
                    }
                }
            }
        }
    }

    function explodeCell(cell) {
        const currentPieces = cell.isPlayer ? playerCells.length : bots.filter(b => b.playerId === cell.playerId).length;
        const canCreate = MAX_PIECES - currentPieces;
        if (canCreate <= 0) return;
        const numNew = Math.min(canCreate, 15);
        const fragmentMass = cell.mass / (numNew + 1);
        cell.mass = fragmentMass;
        for(let i=0; i<numNew; i++) {
            const angle = Math.random() * Math.PI * 2;
            const piece = new Cell(cell.playerId, cell.x, cell.y, fragmentMass, cell.color, cell.name, cell.isPlayer);
            piece.boostX = Math.cos(angle) * SPLIT_FORCE; piece.boostY = Math.sin(angle) * SPLIT_FORCE;
            piece.mergeTimer = MERGE_BASE + Math.pow(cell.mass, 0.35) * MERGE_FACTOR;
            cell.mergeTimer = piece.mergeTimer;
            if (cell.isPlayer) playerCells.push(piece); else bots.push(piece);
        }
    }

    function update() {
        const now = Date.now();
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;
        if (!gameStarted) return;

        if (playerCells.length > 0) {
            let avgX = 0, avgY = 0, totalM = 0;
            playerCells.forEach(c => { avgX += c.x; avgY += c.y; totalM += c.mass; });
            camera.x += (avgX / playerCells.length - camera.x) * 0.1;
            camera.y += (avgY / playerCells.length - camera.y) * 0.1;
            const targetZoom = 2.1 / Math.sqrt(totalM);
            camera.zoom += (targetZoom - camera.zoom) * 0.08;
        } else {
            gameStarted = false;
            document.getElementById('start-screen').style.display = 'flex';
        }

        const worldMouseX = (mouseX - canvas.width/2) / camera.zoom + camera.x;
        const worldMouseY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
        playerCells.forEach(c => c.update(dt, worldMouseX, worldMouseY));
        bots.forEach(b => {
            if (!b.targetFood || Math.random() < 0.01) b.targetFood = foods[Math.floor(Math.random()*foods.length)];
            b.update(dt, b.targetFood ? b.targetFood.x : undefined, b.targetFood ? b.targetFood.y : undefined);
        });
        ejectedMasses.forEach((m, i) => {
            m.x += m.vx * dt; m.y += m.vy * dt;
            const decay = Math.pow(0.05, dt); m.vx *= decay; m.vy *= decay;
        });
        handleCollisions();
        document.getElementById('score').innerText = `Score: ${Math.floor(playerCells.reduce((a,b) => a + b.mass, 0))}`;
    }

    function render() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(canvas.width/2, canvas.height/2);
        ctx.scale(camera.zoom, camera.zoom);
        ctx.translate(-camera.x, -camera.y);

        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 2;
        for(let i=0; i<=WORLD_SIZE; i+=100) { ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, WORLD_SIZE); ctx.stroke(); }
        for(let i=0; i<=WORLD_SIZE; i+=100) { ctx.beginPath(); ctx.moveTo(0, i); ctx.lineTo(WORLD_SIZE, i); ctx.stroke(); }

        foods.forEach(f => { ctx.beginPath(); ctx.arc(f.x, f.y, 10, 0, Math.PI*2); ctx.fillStyle = f.c; ctx.fill(); });
        viruses.forEach(v => {
            ctx.beginPath(); for(let i=0; i<20; i++) {
                const angle = (i/20) * Math.PI*2, r = (i%2===0) ? 100 : 90;
                ctx.lineTo(v.x + Math.cos(angle)*r, v.y + Math.sin(angle)*r);
            }
            ctx.closePath(); ctx.fillStyle = '#33ff33'; ctx.fill(); ctx.strokeStyle = '#22cc22'; ctx.lineWidth = 5; ctx.stroke();
        });
        ejectedMasses.forEach(m => { ctx.beginPath(); ctx.arc(m.x, m.y, getRadius(m.mass), 0, Math.PI*2); ctx.fillStyle = m.c; ctx.fill(); });
        bots.forEach(b => b.draw());
        playerCells.forEach(c => c.draw());
        ctx.restore();
        updateLeaderboard();
    }

    function updateLeaderboard() {
        const players = {};
        [...playerCells, ...bots].forEach(c => {
            if (!players[c.playerId]) players[c.playerId] = { name: c.name, mass: 0, isPlayer: c.isPlayer };
            players[c.playerId].mass += c.mass;
        });
        const sorted = Object.values(players).sort((a,b) => b.mass - a.mass).slice(0, 8);
        document.getElementById('lb-content').innerHTML = sorted.map((p, i) => 
            `<div style="color:${p.isPlayer ? '#000' : '#666'}">${i+1}. ${p.name} (${Math.floor(p.mass)})</div>`
        ).join("");
    }

    window.onmousemove = (e) => { mouseX = e.clientX; mouseY = e.clientY; };
    window.onkeydown = (e) => {
        if (!gameStarted) return;
        if (e.code === 'Space') {
            const count = playerCells.length; if (count >= MAX_PIECES) return;
            const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
            for (let i = 0; i < count; i++) {
                let c = playerCells[i];
                if (c.mass >= MIN_SPLIT_MASS && playerCells.length < MAX_PIECES) {
                    const angle = Math.atan2(worldMY - c.y, worldMX - c.x);
                    c.mass /= 2;
                    const piece = new Cell(c.playerId, c.x, c.y, c.mass, c.color, c.name, true);
                    piece.boostX = Math.cos(angle) * SPLIT_FORCE; piece.boostY = Math.sin(angle) * SPLIT_FORCE;
                    const mTime = MERGE_BASE + Math.pow(c.mass, 0.35) * MERGE_FACTOR;
                    c.mergeTimer = mTime; piece.mergeTimer = mTime;
                    playerCells.push(piece);
                }
            }
        }
        if (e.code === 'KeyW') {
            playerCells.forEach(c => {
                if (c.mass > 120) {
                    const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
                    const angle = Math.atan2(worldMY - c.y, worldMX - c.x);
                    c.mass -= EJECT_LOSS;
                    ejectedMasses.push({ x: c.x + Math.cos(angle) * getRadius(c.mass) * 1.1, y: c.y + Math.sin(angle) * getRadius(c.mass) * 1.1, vx: Math.cos(angle) * 600, vy: Math.sin(angle) * 600, mass: EJECT_MASS, c: c.color });
                }
            });
        }
    };

    function init() {
        for(let i=0; i<FOOD_COUNT; i++) spawnFood();
        for(let i=0; i<VIRUS_COUNT; i++) viruses.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, mass: VIRUS_MASS });
        for(let i=0; i<12; i++) {
            const id = generateId();
            bots.push(new Cell(id, Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[i%COLORS.length], BOT_NAMES[i % BOT_NAMES.length]));
        }
    }

    function run() { update(); render(); requestAnimationFrame(run); }
    init(); run();
    </script>
</body>
</html>

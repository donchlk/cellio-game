<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cell.io - Technical Pro Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #f2fbff; font-family: 'Ubuntu', sans-serif; }
        canvas { display: block; }
        #hud { position: absolute; top: 20px; left: 20px; color: #555; pointer-events: none; z-index: 10; }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 5px; min-width: 150px; color: #444; font-size: 14px; backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.1); z-index: 10; }
        .score-val { font-weight: bold; font-size: 20px; }
        #instructions { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); color: #999; font-size: 12px; z-index: 10; }
        
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 100;
        }
        .login-box {
            background: white; padding: 30px; border-radius: 10px; text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .login-box h1 { margin-top: 0; color: #333; }
        .login-box input {
            width: 100%; padding: 12px; margin: 15px 0; border: 2px solid #ddd; border-radius: 5px; font-size: 16px; box-sizing: border-box;
        }
        .login-box button {
            background: #ff3f3f; color: white; border: none; padding: 12px 30px; border-radius: 5px; font-size: 18px; cursor: pointer; transition: 0.2s;
        }
        .login-box button:hover { background: #e63535; }
    </style>
</head>
<body>
    <div id="start-screen">
        <div class="login-box">
            <h1>Cell.io</h1>
            <input type="text" id="nickname" placeholder="Nickname" maxlength="15">
            <br>
            <button onclick="startGame()">Play</button>
        </div>
    </div>

    <div id="hud" style="display:none">
        <div class="score-val">Score: <span id="score">0</span></div>
    </div>
    <div id="leaderboard" style="display:none">
        <div style="font-weight:bold; border-bottom:1px solid #ccc; margin-bottom:5px; padding-bottom:2px;">Leaderboard</div>
        <div id="lb-content"></div>
    </div>
    <div id="instructions" style="display:none">[Space] Split | [W] Eject Mass | Move Mouse to steer</div>
    <canvas id="game"></canvas>

<script>
const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
const WORLD_SIZE = 5000, INITIAL_MASS = 250, MIN_SPLIT_MASS = 450, MAX_PIECES = 16, FOOD_COUNT = 1000, VIRUS_COUNT = 35, VIRUS_MASS = 1200;
const BASE_SPEED = 2200, EJECT_MASS = 35, EJECT_LOSS = 42, DECAY_RATE = 0.0025, FRICTION = 0.08;
const COLORS = ['#33ff33', '#3333ff', '#ff3333', '#ffff33', '#ff33ff', '#33ffff', '#ff9900', '#7d5fff'];
const BOT_NAMES = ["Sir Eats-a-lot", "Cell-fie", "Wojak", "Dogecoin", "Sanic", "MemeLord", "Doge", "Spooderman", "Blobby", "AgarioMaster", "ProCell", "Noob", "Ghost", "Predator", "Survivor"];

let lastTime = Date.now(), mouseX = 0, mouseY = 0, playerCells = [], bots = [], foods = [], viruses = [], ejectedMasses = [], camera = { x: WORLD_SIZE/2, y: WORLD_SIZE/2, zoom: 1 };
let gameStarted = false;

const getRadius = (mass) => Math.sqrt(mass);
const getSpeed = (mass) => BASE_SPEED / Math.pow(mass, 0.44);

class Cell {
    constructor(x, y, mass, color, name, isPlayer = false) {
        this.x = x; this.y = y; this.mass = mass; this.color = color; this.name = name; this.isPlayer = isPlayer;
        this.boostX = 0; this.boostY = 0; this.mergeTimer = 0;
    }
    update(dt, targetX, targetY) {
        const r = getRadius(this.mass), s = getSpeed(this.mass);
        if (targetX !== undefined) {
            const dx = targetX - this.x, dy = targetY - this.y, dist = Math.hypot(dx, dy);
            if (dist > 1) {
                this.x += (dx / dist) * s * dt;
                this.y += (dy / dist) * s * dt;
            }
        }
        this.x += this.boostX * dt; this.y += this.boostY * dt;
        const decay = Math.pow(FRICTION, dt); this.boostX *= decay; this.boostY *= decay;
        this.x = Math.max(r, Math.min(WORLD_SIZE - r, this.x));
        this.y = Math.max(r, Math.min(WORLD_SIZE - r, this.y));
        if (this.mass > INITIAL_MASS) this.mass -= this.mass * DECAY_RATE * dt;
        if (this.mergeTimer > 0) this.mergeTimer -= dt;
    }
    draw() {
        const r = getRadius(this.mass);
        ctx.save(); ctx.translate(this.x, this.y);
        ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI * 2); ctx.fillStyle = this.color; ctx.fill();
        ctx.lineWidth = Math.max(2, r * 0.04); ctx.strokeStyle = 'rgba(0,0,0,0.1)'; ctx.stroke();
        const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
        grad.addColorStop(0.8, 'rgba(255,255,255,0)'); grad.addColorStop(1, 'rgba(255,255,255,0.15)');
        ctx.fillStyle = grad; ctx.fill();
        if (r > 12) {
            ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.font = `bold ${r * 0.38}px Ubuntu, sans-serif`;
            ctx.fillText(this.name, 0, r * 0.1);
            if (r > 25) {
                ctx.font = `${r * 0.22}px Ubuntu, sans-serif`;
                ctx.fillText(Math.floor(this.mass), 0, r * 0.45);
            }
        }
        ctx.restore();
    }
}

function startGame() {
    const nick = document.getElementById('nickname').value || 'Unnamed Cell';
    playerCells = [new Cell(WORLD_SIZE/2, WORLD_SIZE/2, INITIAL_MASS, '#ff3f3f', nick, true)];
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    document.getElementById('leaderboard').style.display = 'block';
    document.getElementById('instructions').style.display = 'block';
    gameStarted = true;
}

function spawnFood() {
    foods.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, c: COLORS[Math.floor(Math.random()*COLORS.length)], m: 12 });
}

function update() {
    const now = Date.now(), dt = (now - lastTime) / 1000;
    lastTime = now;
    if (!gameStarted) return;

    if (playerCells.length > 0) {
        let avgX = 0, avgY = 0, totalM = 0;
        playerCells.forEach(c => { avgX += c.x; avgY += c.y; totalM += c.mass; });
        camera.x += (avgX / playerCells.length - camera.x) * 0.1;
        camera.y += (avgY / playerCells.length - camera.y) * 0.1;
        const targetZoom = 1 / Math.pow(totalM / 400, 0.35);
        camera.zoom += (targetZoom - camera.zoom) * 0.05;
    } else {
        gameStarted = false;
        document.getElementById('start-screen').style.display = 'flex';
    }

    const worldMouseX = (mouseX - canvas.width/2) / camera.zoom + camera.x;
    const worldMouseY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
    playerCells.forEach(c => c.update(dt, worldMouseX, worldMouseY));
    bots.forEach(b => {
        if (!b.targetFood || Math.random() < 0.01) b.targetFood = foods[Math.floor(Math.random()*foods.length)];
        b.update(dt, b.targetFood.x, b.targetFood.y);
    });
    ejectedMasses.forEach((m, i) => {
        m.x += m.vx * dt; m.y += m.vy * dt;
        const decay = Math.pow(0.05, dt); m.vx *= decay; m.vy *= decay;
    });
    handleCollisions();
    document.getElementById('score').innerText = Math.floor(playerCells.reduce((a,b) => a + b.mass, 0));
}

function handleCollisions() {
    const allLivingCells = [...playerCells, ...bots];
    allLivingCells.forEach(c => {
        const r = getRadius(c.mass);
        for(let i=foods.length-1; i>=0; i--) {
            if (Math.hypot(c.x - foods[i].x, c.y - foods[i].y) < r) {
                c.mass += foods[i].m; foods.splice(i, 1); spawnFood();
            }
        }
    });
    allLivingCells.forEach(c => {
        const r = getRadius(c.mass);
        viruses.forEach(v => {
            const dist = Math.hypot(c.x - v.x, c.y - v.y);
            if (c.mass > v.mass * 1.15 && dist < r) explodeCell(c);
        });
    });
    for(let i=allLivingCells.length-1; i>=0; i--) {
        for(let j=allLivingCells.length-1; j>=0; j--) {
            if (i === j) continue;
            let a = allLivingCells[i], b = allLivingCells[j];
            if (!a || !b) continue;
            const dist = Math.hypot(a.x - b.x, a.y - b.y), ra = getRadius(a.mass), rb = getRadius(b.mass);
            if (a.name === b.name && a.isPlayer === b.isPlayer) {
                if (a.mergeTimer <= 0 && b.mergeTimer <= 0 && dist < ra * 0.4) {
                    a.mass += b.mass;
                    if (a.isPlayer) playerCells.splice(playerCells.indexOf(b), 1);
                    else bots.splice(bots.indexOf(b), 1);
                    return;
                }
                if (dist < ra + rb) {
                    const angle = Math.atan2(b.y - a.y, b.x - a.x), push = (ra + rb - dist) * 0.1;
                    b.x += Math.cos(angle) * push; b.y += Math.sin(angle) * push;
                }
            } else {
                if (a.mass > b.mass * 1.25 && dist < ra - rb * 0.45) {
                    a.mass += b.mass;
                    if (b.isPlayer) playerCells.splice(playerCells.indexOf(b), 1);
                    else bots.splice(bots.indexOf(b), 1);
                    if (!b.isPlayer) setTimeout(() => {
                        bots.push(new Cell(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[Math.floor(Math.random()*COLORS.length)], BOT_NAMES[Math.floor(Math.random()*BOT_NAMES.length)]));
                    }, 5000);
                }
            }
        }
    }
}

function explodeCell(cell) {
    if (cell.mass < 600) return;
    const piecesToSpawn = Math.min(MAX_PIECES - 1, 8), fragmentMass = cell.mass / (piecesToSpawn + 1);
    cell.mass = fragmentMass;
    for(let i=0; i<piecesToSpawn; i++) {
        const angle = Math.random() * Math.PI * 2, piece = new Cell(cell.x, cell.y, fragmentMass, cell.color, cell.name, cell.isPlayer);
        piece.boostX = Math.cos(angle) * 700; piece.boostY = Math.sin(angle) * 700;
        piece.mergeTimer = 18 + (fragmentMass * 0.015);
        if (cell.isPlayer) playerCells.push(piece); else bots.push(piece);
    }
}

function render() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save(); ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(camera.zoom, camera.zoom); ctx.translate(-camera.x, -camera.y);
    ctx.strokeStyle = '#e1eff6'; ctx.lineWidth = 1;
    for(let x=0; x<=WORLD_SIZE; x+=50) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, WORLD_SIZE); ctx.stroke(); }
    for(let y=0; y<=WORLD_SIZE; y+=50) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(WORLD_SIZE, y); ctx.stroke(); }
    ctx.strokeStyle = 'rgba(255, 63, 63, 0.4)'; ctx.lineWidth = 15; ctx.strokeRect(0, 0, WORLD_SIZE, WORLD_SIZE);
    foods.forEach(f => { ctx.fillStyle = f.c; ctx.beginPath(); ctx.arc(f.x, f.y, 11, 0, Math.PI*2); ctx.fill(); });
    ejectedMasses.forEach(m => { ctx.fillStyle = m.c; ctx.beginPath(); ctx.arc(m.x, m.y, getRadius(m.mass), 0, Math.PI*2); ctx.fill(); });
    viruses.forEach(v => {
        const r = getRadius(v.mass); ctx.fillStyle = '#33ff33'; ctx.strokeStyle = '#2ac82a'; ctx.lineWidth = 6; ctx.beginPath();
        for(let i=0; i<20; i++) { let angle = (i / 20) * Math.PI * 2, d = i % 2 === 0 ? r : r * 1.15; ctx.lineTo(v.x + Math.cos(angle) * d, v.y + Math.sin(angle) * d); }
        ctx.closePath(); ctx.fill(); ctx.stroke();
    });
    bots.forEach(b => b.draw()); playerCells.forEach(c => c.draw());
    ctx.restore(); updateLeaderboard();
}

function updateLeaderboard() {
    const list = [...playerCells, ...bots];
    const top = list.sort((a,b) => b.mass - a.mass).slice(0, 8);
    document.getElementById('lb-content').innerHTML = top.map((c, i) => `<div style="color:${c.isPlayer?'#000':'#666'}">${i+1}. ${c.name} (${Math.floor(c.mass)})</div>`).join("");
}

window.onmousemove = (e) => { mouseX = e.clientX; mouseY = e.clientY; };
window.onkeydown = (e) => {
    if (!gameStarted) return;
    if (e.code === 'Space') {
        if (playerCells.length >= MAX_PIECES) return;
        const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
        for (let i = playerCells.length - 1; i >= 0; i--) {
            let c = playerCells[i];
            if (c.mass >= MIN_SPLIT_MASS && playerCells.length < MAX_PIECES) {
                const angle = Math.atan2(worldMY - c.y, worldMX - c.x); c.mass /= 2;
                const piece = new Cell(c.x, c.y, c.mass, c.color, c.name, true);
                piece.boostX = Math.cos(angle) * 850; piece.boostY = Math.sin(angle) * 850;
                piece.mergeTimer = 10 + (c.mass * 0.02); playerCells.push(piece);
            }
        }
    }
    if (e.code === 'KeyW') {
        playerCells.forEach(c => {
            if (c.mass > 120) {
                const worldMX = (mouseX - canvas.width/2) / camera.zoom + camera.x, worldMY = (mouseY - canvas.height/2) / camera.zoom + camera.y;
                const angle = Math.atan2(worldMY - c.y, worldMX - c.x);
                c.mass -= EJECT_LOSS;
                ejectedMasses.push({ x: c.x + Math.cos(angle) * getRadius(c.mass) * 1.1, y: c.y + Math.sin(angle) * getRadius(c.mass) * 1.1, vx: Math.cos(angle) * 600, vy: Math.sin(angle) * 600, mass: EJECT_MASS, c: c.color });
            }
        });
    }
};

function init() {
    for(let i=0; i<FOOD_COUNT; i++) spawnFood();
    for(let i=0; i<VIRUS_COUNT; i++) viruses.push({ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, mass: VIRUS_MASS });
    for(let i=0; i<12; i++) bots.push(new Cell(Math.random()*WORLD_SIZE, Math.random()*WORLD_SIZE, INITIAL_MASS, COLORS[i%COLORS.length], BOT_NAMES[Math.floor(Math.random()*BOT_NAMES.length)]));
}
function run() { update(); render(); requestAnimationFrame(run); }
init(); run();
</script>
</body>
</html>

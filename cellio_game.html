<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Cell.io ‚Äì Mini Agar Clone</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
  canvas { display: block; cursor: none; }
  #ui {
    position: fixed; top: 16px; left: 50%; transform: translateX(-50%);
    color: white; text-align: center; pointer-events: none;
  }
  #score { font-size: 22px; font-weight: 700; text-shadow: 0 2px 8px rgba(0,0,0,0.8); }
  #leaderboard {
    position: fixed; top: 16px; right: 16px;
    background: rgba(0,0,0,0.55); backdrop-filter: blur(6px);
    border-radius: 10px; padding: 12px 18px; color: white; min-width: 160px;
    border: 1px solid rgba(255,255,255,0.1);
  }
  #leaderboard h3 { font-size: 13px; letter-spacing: 1px; text-transform: uppercase; opacity: 0.7; margin-bottom: 8px; }
  #leaderboard ol { padding-left: 18px; font-size: 13px; line-height: 1.8; }
  #leaderboard li.me { color: #7DF9AA; font-weight: 700; }
  #info {
    position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%);
    color: rgba(255,255,255,0.45); font-size: 12px; pointer-events: none;
  }
  #respawn {
    display: none; position: fixed; inset: 0;
    background: rgba(0,0,0,0.75); color: white;
    flex-direction: column; align-items: center; justify-content: center;
    gap: 16px;
  }
  #respawn h2 { font-size: 36px; }
  #respawn p { opacity: 0.7; }
  #respawn button {
    background: #7DF9AA; color: #111; border: none; padding: 12px 36px;
    border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui"><div id="score">Masse: 10</div></div>
<div id="leaderboard"><h3>üèÜ Top 5</h3><ol id="lbList"></ol></div>
<div id="info">Maus bewegen zum Steuern ‚Äì Zelle frisst kleinere Gegner</div>
<div id="respawn">
  <h2>üíÄ Du wurdest gefressen!</h2>
  <p id="finalScore"></p>
  <button onclick="respawn()">Nochmal spielen</button>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const W = 3000, H = 3000;
let mouse = { x: 0, y: 0 };
let cam = { x: 0, y: 0, zoom: 1 };

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);
window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

// ‚îÄ‚îÄ Color palette ‚îÄ‚îÄ
const COLORS = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#FF922B','#CC5DE8','#20C997','#F06595','#74C0FC','#A9E34B'];

// ‚îÄ‚îÄ Food pellets ‚îÄ‚îÄ
const FOOD_COUNT = 600;
let foods = [];
function spawnFood(n = 1) {
  for (let i = 0; i < n; i++) {
    foods.push({
      x: Math.random() * W,
      y: Math.random() * H,
      r: 5 + Math.random() * 4,
      color: COLORS[Math.floor(Math.random() * COLORS.length)]
    });
  }
}
spawnFood(FOOD_COUNT);

// ‚îÄ‚îÄ Bot names ‚îÄ‚îÄ
const BOT_NAMES = ['Zellchen','BlobX','MaxMass','CellBot','GrowFast','NomNom','BigBoss','Splitter','Absorber','LilBlob'];

// ‚îÄ‚îÄ Player ‚îÄ‚îÄ
let player;
function makePlayer() {
  return {
    x: W / 2, y: H / 2,
    r: 18, mass: 10,
    color: '#7DF9AA', name: 'Du',
    isPlayer: true, alive: true
  };
}

// ‚îÄ‚îÄ Bots ‚îÄ‚îÄ
let bots = [];
function makeBots() {
  bots = [];
  for (let i = 0; i < 12; i++) {
    bots.push({
      x: Math.random() * W, y: Math.random() * H,
      r: 12 + Math.random() * 20,
      mass: massFromR(12 + Math.random() * 20),
      color: COLORS[i % COLORS.length],
      name: BOT_NAMES[i % BOT_NAMES.length],
      vx: 0, vy: 0,
      targetTimer: 0,
      tx: Math.random() * W, ty: Math.random() * H,
      isPlayer: false, alive: true
    });
  }
}

function rFromMass(m) { return Math.sqrt(m) * 5; }
function massFromR(r) { return (r / 5) ** 2; }

// ‚îÄ‚îÄ Movement speed (larger = slower) ‚îÄ‚îÄ
function speed(r) { return Math.max(1.2, 7 - r * 0.04); }

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ
player = makePlayer();
makeBots();

// ‚îÄ‚îÄ Game loop ‚îÄ‚îÄ
let last = performance.now();
let dead = false;

function update(dt) {
  if (dead) return;

  // Player movement
  const cx = canvas.width / 2, cy = canvas.height / 2;
  const dx = mouse.x - cx, dy = mouse.y - cy;
  const dist = Math.hypot(dx, dy) || 1;
  const sp = speed(player.r);
  const nx = dx / dist, ny = dy / dist;
  player.x = Math.max(player.r, Math.min(W - player.r, player.x + nx * sp * dt * 60));
  player.y = Math.max(player.r, Math.min(H - player.r, player.y + ny * sp * dt * 60));

  // Camera
  const targetZoom = Math.max(0.35, Math.min(1, 50 / player.r));
  cam.zoom += (targetZoom - cam.zoom) * 0.05;
  cam.x += (player.x - cam.x) * 0.08;
  cam.y += (player.y - cam.y) * 0.08;

  // Player eats food
  for (let i = foods.length - 1; i >= 0; i--) {
    const f = foods[i];
    if (Math.hypot(player.x - f.x, player.y - f.y) < player.r) {
      player.mass += 0.5;
      player.r = rFromMass(player.mass);
      foods.splice(i, 1);
    }
  }

  // Bots AI + movement
  for (const bot of bots) {
    if (!bot.alive) continue;
    bot.targetTimer -= dt;
    if (bot.targetTimer <= 0) {
      bot.targetTimer = 0.5 + Math.random() * 1.5;
      // flee from bigger, chase smaller
      let bestScore = -Infinity, bx = -1, by = -1;
      const allCells = [player, ...bots.filter(b => b !== bot && b.alive)];
      for (const c of allCells) {
        const d = Math.hypot(bot.x - c.x, bot.y - c.y);
        const score = (bot.r > c.r * 1.1) ? 1000 / (d + 1) : -500 / (d + 1);
        if (score > bestScore) { bestScore = score; bx = c.x; by = c.y; }
      }
      // also wander toward food
      let nearFood = null, nfd = Infinity;
      for (const f of foods) {
        const d = Math.hypot(bot.x - f.x, bot.y - f.y);
        if (d < nfd) { nfd = d; nearFood = f; }
      }
      if (nearFood && nfd < 200) { bot.tx = nearFood.x; bot.ty = nearFood.y; }
      else if (bx >= 0) { bot.tx = bx; bot.ty = by; }
      else { bot.tx = Math.random() * W; bot.ty = Math.random() * H; }
    }
    const bdx = bot.tx - bot.x, bdy = bot.ty - bot.y;
    const bd = Math.hypot(bdx, bdy) || 1;
    const bsp = speed(bot.r);
    bot.x = Math.max(bot.r, Math.min(W - bot.r, bot.x + bdx / bd * bsp * dt * 60));
    bot.y = Math.max(bot.r, Math.min(H - bot.r, bot.y + bdy / bd * bsp * dt * 60));

    // Bot eats food
    for (let i = foods.length - 1; i >= 0; i--) {
      const f = foods[i];
      if (Math.hypot(bot.x - f.x, bot.y - f.y) < bot.r) {
        bot.mass += 0.5; bot.r = rFromMass(bot.mass); foods.splice(i, 1);
      }
    }
  }

  // Eat collisions between all cells
  const allCells = [player, ...bots];
  for (let i = 0; i < allCells.length; i++) {
    const a = allCells[i];
    if (!a.alive) continue;
    for (let j = 0; j < allCells.length; j++) {
      if (i === j) continue;
      const b = allCells[j];
      if (!b.alive) continue;
      if (a.r > b.r * 1.1) {
        const d = Math.hypot(a.x - b.x, a.y - b.y);
        if (d < a.r * 0.85) {
          a.mass += b.mass;
          a.r = rFromMass(a.mass);
          b.alive = false;
          if (b.isPlayer) { dead = true; showDead(); return; }
          // Respawn bot later
          setTimeout(() => respawnBot(b), 3000);
        }
      }
    }
  }

  // Refill food
  if (foods.length < FOOD_COUNT - 10) spawnFood(5);

  // Mass decay (slow shrink)
  if (player.mass > 10) { player.mass = Math.max(10, player.mass * 0.9998); player.r = rFromMass(player.mass); }
  for (const bot of bots) {
    if (!bot.alive || bot.mass <= 10) continue;
    bot.mass = Math.max(10, bot.mass * 0.9998); bot.r = rFromMass(bot.mass);
  }

  // HUD
  document.getElementById('score').textContent = 'Masse: ' + Math.floor(player.mass);
  updateLeaderboard();
}

function respawnBot(bot) {
  bot.x = Math.random() * W; bot.y = Math.random() * H;
  bot.mass = 10 + Math.random() * 20;
  bot.r = rFromMass(bot.mass);
  bot.alive = true;
}

function showDead() {
  const el = document.getElementById('respawn');
  el.style.display = 'flex';
  document.getElementById('finalScore').textContent = 'Erreichte Masse: ' + Math.floor(player.mass);
}

function respawn() {
  dead = false;
  player = makePlayer();
  makeBots();
  foods = [];
  spawnFood(FOOD_COUNT);
  document.getElementById('respawn').style.display = 'none';
}

function updateLeaderboard() {
  const entries = [player, ...bots.filter(b => b.alive)]
    .sort((a, b) => b.mass - a.mass).slice(0, 5);
  const ol = document.getElementById('lbList');
  ol.innerHTML = entries.map(e =>
    `<li class="${e.isPlayer ? 'me' : ''}">${e.name} ‚Äì ${Math.floor(e.mass)}</li>`
  ).join('');
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  const ox = canvas.width / 2 - cam.x * cam.zoom;
  const oy = canvas.height / 2 - cam.y * cam.zoom;
  ctx.translate(ox, oy);
  ctx.scale(cam.zoom, cam.zoom);

  // Grid background
  ctx.strokeStyle = 'rgba(255,255,255,0.04)';
  ctx.lineWidth = 1 / cam.zoom;
  const gs = 60;
  const sx = Math.floor((cam.x - canvas.width / 2 / cam.zoom) / gs) * gs;
  const sy = Math.floor((cam.y - canvas.height / 2 / cam.zoom) / gs) * gs;
  for (let gx = sx; gx < sx + canvas.width / cam.zoom + gs; gx += gs) {
    ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, H); ctx.stroke();
  }
  for (let gy = sy; gy < sy + canvas.height / cam.zoom + gs; gy += gs) {
    ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(W, gy); ctx.stroke();
  }

  // Border
  ctx.strokeStyle = 'rgba(255,100,100,0.4)';
  ctx.lineWidth = 6 / cam.zoom;
  ctx.strokeRect(0, 0, W, H);

  // Food
  for (const f of foods) {
    ctx.beginPath();
    ctx.arc(f.x, f.y, f.r, 0, Math.PI * 2);
    ctx.fillStyle = f.color;
    ctx.fill();
    ctx.shadowColor = f.color;
    ctx.shadowBlur = 6;
    ctx.fill();
    ctx.shadowBlur = 0;
  }

  // Cells
  const drawCell = (c) => {
    if (!c.alive) return;
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI * 2);
    ctx.fillStyle = c.color;
    ctx.shadowColor = c.color;
    ctx.shadowBlur = c.isPlayer ? 18 : 8;
    ctx.fill();
    ctx.shadowBlur = 0;
    // Border
    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.lineWidth = 2 / cam.zoom;
    ctx.stroke();
    // Name
    if (c.r > 12) {
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      const fs = Math.max(10, Math.min(c.r * 0.45, 22));
      ctx.font = `bold ${fs}px Segoe UI`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(c.name, c.x, c.y);
    }
  };

  for (const bot of bots) drawCell(bot);
  drawCell(player);

  // Custom cursor cross
  const mx = (mouse.x - ox) / cam.zoom, my = (mouse.y - oy) / cam.zoom;
  ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  ctx.lineWidth = 1 / cam.zoom;
  ctx.beginPath(); ctx.moveTo(mx - 10 / cam.zoom, my); ctx.lineTo(mx + 10 / cam.zoom, my); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(mx, my - 10 / cam.zoom); ctx.lineTo(mx, my + 10 / cam.zoom); ctx.stroke();

  ctx.restore();
}

function loop(now) {
  const dt = Math.min((now - last) / 1000, 0.05);
  last = now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(t => { last = t; loop(t); });
</script>
</body>
</html>
